{"entries":[{"timestamp":1733900476970,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"http"],[-1,"s"],[0,"://"],[-1,"developers.google.com/blockly/xml\"><variables></variables><block type=\"device_forever\" id=\"oN%vT)U;,`x_WL9(Hup[\" x=\"0\" y=\"0"],[1,"www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever"],[0,"\"></"]],"start1":12,"start2":12,"length1":135,"length2":102},{"diffs":[[0,"</block>"],[1,"\n"],[0,"</xml>"]],"start1":112,"start2":112,"length1":14,"length2":15}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"basic.forever(function () {\n\t\n})"],[0,"\n"]],"start1":0,"start2":0,"length1":33,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,".md\""],[-1,",\n        \"onebit.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"preferredEditor\": \"blocksprj\""],[1,"\n    ],\n    \"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":217,"start2":217,"length1":114,"length2":44}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"},{"type":"added","filename":"onebit.ts","value":"/**\n * Custom blocks for One:Bit\n */\n//% weight=100 color=#993366 icon=\"\\uf2db\" block=\"One:Bit\"\nnamespace One_Bit {\n\n    // Define custom enums for digital pins\n    export enum DigitalPinPrime {\n        //% block=\"P0\"\n        P0 = DigitalPin.P0,\n        //% block=\"P1\"\n        P1 = DigitalPin.P1,\n        //% block=\"P2\"\n        P2 = DigitalPin.P2,\n        //% block=\"P3\"\n        P3 = DigitalPin.P3,\n        //% block=\"P4\"\n        P4 = DigitalPin.P4,\n        //% block=\"P9\"\n        P9 = DigitalPin.P9,\n        //% block=\"P10\"\n        P10 = DigitalPin.P10,\n        //% block=\"P13\"\n        P13 = DigitalPin.P13,\n        //% block=\"P14\"\n        P14 = DigitalPin.P14,\n        //% block=\"P15\"\n        P15 = DigitalPin.P15,\n        //% block=\"P19\"\n        P19 = DigitalPin.P19,\n        //% block=\"P20\"\n        P20 = DigitalPin.P20\n    }\n\n    // Define custom enums for analog pins\n    export enum AnalogPinPrime {\n        //% block=\"P0\"\n        P0 = AnalogPin.P0,\n        //% block=\"P1\"\n        P1 = AnalogPin.P1,\n        //% block=\"P2\"\n        P2 = AnalogPin.P2,\n        //% block=\"P3\"\n        P3 = AnalogPin.P3,\n        //% block=\"P4\"\n        P4 = AnalogPin.P4,\n        //% block=\"P10\"\n        P10 = AnalogPin.P10\n    }\n\n\n    // Enum for PWM pins\n    export enum PWM {\n        //% block=\"P0\"\n        P0 = DigitalPin.P0,\n        //% block=\"P1\"\n        P1 = DigitalPin.P1,\n        //% block=\"P2\"\n        P2 = DigitalPin.P2,\n        //% block=\"P8\"\n        P8 = DigitalPin.P8,\n        //% block=\"P12\"\n        P12 = DigitalPin.P12,\n        //% block=\"P13\"\n        P13 = DigitalPin.P13,\n        //% block=\"P14\"\n        P14 = DigitalPin.P14,\n        //% block=\"P15\"\n        P15 = DigitalPin.P15,\n        //% block=\"P16\"\n        P16 = DigitalPin.P16\n    }\n\n\n    ////////////////////\n    //  PRIME BLOCKS  //\n    ////////////////////\n\n    // Function for reading a digital value from a pin\n    //% subcategory=\"Prime\"\n    //% group=\"Digital Pins\"\n    //% weight=150 blockGap=8\n    //% blockId=\"digital_read\"\n    //% block=\"read digital pin %pin\"\n    export function digitalRead(pin: DigitalPinPrime): number {\n        return pins.digitalReadPin(pin);\n    }\n\n    // Function for writing a digital value to a pin\n    //% subcategory=\"Prime\"\n    //% group=\"Digital Pins\"\n    //% blockId=\"digital_write\"\n    //% weight=140 blockGap= 50\n    //% block=\"write digital pin %pin |to %value\"\n    export function digitalWrite(pin: DigitalPinPrime, value: number): void {\n        pins.digitalWritePin(pin, value);\n    }\n\n    // Function for reading an analog value from a pin\n    //% subcategory=\"Prime\"\n    //% group=\"Analog Pins\"\n    //% blockId=\"analog_read\"\n    //% weight=130 blockGap=8\n    //% block=\"read analog pin %pin\"\n    export function analogRead(pin: AnalogPinPrime): number {\n        return pins.analogReadPin(pin);\n    }\n\n    // Function for writing an analog value to a pin\n    //% subcategory=\"Prime\"\n    //% group=\"Analog Pins\"\n    //% weight=120 blockGap=8\n    //% blockId=\"analog_write\"\n    //% block=\"write analog pin %pin |to %value \"\n    //% value.min=0 value.max=1023\n    export function analogWrite(pin: AnalogPinPrime, value: number): void {\n        pins.analogWritePin(pin, value);\n    }\n\n\n\n    let primeBuffer: Buffer = null; // LED data buffer\n    let primeNumLeds: number = 12;  // Number of LEDs\n    let primeBrightness: number = 255; // Default brightness\n\n\n    /**\n     * Initialize the Prime\n     * @param numLeds number of LEDs in the strip\n     */\n    //% subcategory=\"Prime\"\n    //% blockId=\"one_bit_prime_initialize\"\n    //% group=\"Neo_Color\"\n    //% block=\"initialize Prime with %numLeds|LEDs\"\n    //% weight=150 blockGap=8\n    //% blockNamespace=\"One_Bit\"\n    export function initializePrime(numLeds: number): void {\n        primeNumLeds = numLeds;\n        primeBuffer = control.createBuffer(numLeds * 3);\n        clearPrime(); // Ensure all LEDs start off\n    }\n\n    /**\n     * Show data on the LEDs\n     */\n    function showPrimeBuffer(): void {\n        if (primeBuffer) {\n            light.sendWS2812Buffer(primeBuffer, DigitalPin.P16);\n        }\n    }\n\n    /**\n     * Show rainbow colors on the strip\n     */\n    //% subcategory=\"Prime\"\n    //% group=\"Neo_Color\"\n    //% blockId=\"one_bit_prime_show_rainbow\"\n    //% block=\"show Prime\"\n    //% weight=140 blockGap=8\n    export function showPrime(): void {\n        if (primeBuffer) {\n            for (let i = 0; i < primeNumLeds; i++) {\n                let angle = (i / primeNumLeds) * 2 * Math.PI;\n                let red = Math.max(0, Math.sin(angle + (1 / 3) * Math.PI) * 127 + 128);\n                let green = Math.max(0, Math.sin(angle + (2 / 3) * Math.PI) * 127 + 128);\n                let blue = Math.max(0, Math.sin(angle + (4 / 3) * Math.PI) * 127 + 128);\n                setPrimeLedColorRaw(i, Math.floor(red), Math.floor(green), Math.floor(blue));\n            }\n            showPrimeBuffer();\n        }\n    }\n\n    /**\n     * Clear all LEDs on the strip\n     */\n    //% subcategory=\"Prime\"\n    //% group=\"Neo_Color\"\n    //% blockId=\"one_bit_prime_clear\"\n    //% block=\"clear Prime\"\n    //% weight=130 blockGap=8\n    export function clearPrime(): void {\n        if (primeBuffer) {\n            primeBuffer.fill(0);\n            showPrimeBuffer();\n        }\n    }\n\n\n    /**\n     * Set color of all LEDs on the strip\n     * @param color the color to set\n     */\n    //% subcategory=\"Prime\"\n    //% value.defl='#ff0000'\n    //% group=\"Neo_Color\"\n    //% blockId=\"one_bit_prime_set_color\"\n    //% block=\"set Prime color to %color\"\n    //% weight=120 blockGap=8\n    //% color.shadow=\"brightColorNumberPicker\"\n    export function setPrimeColor(color: number): void {\n        let red = (color >> 16) & 0xFF;\n        let green = (color >> 8) & 0xFF;\n        let blue = color & 0xFF;\n        for (let i = 0; i < primeNumLeds; i++) {\n            setPrimeLedColorRaw(i, red, green, blue);\n        }\n        showPrimeBuffer();\n    }\n\n    /**\n * Set color of a specific LED on the strip\n * @param ledIndex the index of the LED to change\n * @param color the color to set\n */\n    //% subcategory=\"Prime\"\n    //% value.defl='#FFFFFF'\n    //% group=\"Neo_Color\"\n    //% blockId=\"one_bit_prime_set_led_color\"\n    //% block=\"set Prime LED %ledIndex|color to %color\"\n    //% weight=110 blockGap=8\n    //% color.shadow=\"brightColorNumberPicker\"\n    export function setPrimeLedColor(ledIndex: number, color: number): void {\n        if (primeBuffer && ledIndex < primeNumLeds) {\n            let red = (color >> 16) & 0xFF;\n            let green = (color >> 8) & 0xFF;\n            let blue = color & 0xFF;\n\n            let index = ledIndex * 3; // Calculate position in buffer\n            primeBuffer.setUint8(index, (red * primeBrightness) >> 8); // Scale brightness\n            primeBuffer.setUint8(index + 1, (green * primeBrightness) >> 8); // Scale brightness\n            primeBuffer.setUint8(index + 2, (blue * primeBrightness) >> 8); // Scale brightness\n\n            showPrimeBuffer(); // Send updated buffer to the LEDs\n        }\n    }\n\n\n    /**\n     * Set brightness of the strip\n     * @param brightness brightness level (0-255)\n     */\n    //% subcategory=\"Prime\"\n    //% group=\"Neo_Color\"\n    //% blockId=\"one_bit_prime_set_brightness\"\n    //% block=\"set Prime brightness to %brightness\"\n    //% weight=100 blockGap=8\n    export function setPrimeBrightness(brightness: number): void {\n        primeBrightness = Math.clamp(0, 255, brightness);\n        applyBrightness(); // Apply brightness scaling to the buffer\n        showPrimeBuffer(); // Update LEDs with adjusted brightness\n    }\n\n    /**\n     * Apply brightness scaling to the buffer\n     */\n    function applyBrightness(): void {\n        if (!primeBuffer) return;\n\n        for (let i = 0; i < primeNumLeds; i++) {\n            let index = i * 3;\n            primeBuffer[index] = (primeBuffer[index] * primeBrightness) >> 8; // Scale Green\n            primeBuffer[index + 1] = (primeBuffer[index + 1] * primeBrightness) >> 8; // Scale Red\n            primeBuffer[index + 2] = (primeBuffer[index + 2] * primeBrightness) >> 8; // Scale Blue\n        }\n    }\n    /**\n     * Set color of a specific LED using raw RGB values\n     * @param ledIndex the index of the LED to change\n     * @param red Red value (0-255)\n     * @param green Green value (0-255)\n     * @param blue Blue value (0-255)\n     */\n    function setPrimeLedColorRaw(index: number, red: number, green: number, blue: number): void {\n        if (!primeBuffer || index >= primeNumLeds) return;\n\n        let brightnessScale = primeBrightness / 255; // Scale factor for brightness\n        primeBuffer[index * 3 + 0] = Math.floor(green * brightnessScale); // GRB: Green\n        primeBuffer[index * 3 + 1] = Math.floor(red * brightnessScale);   // GRB: Red\n        primeBuffer[index * 3 + 2] = Math.floor(blue * brightnessScale);  // GRB: Blue\n    }\n\n    /**\n     * Show a gradient pattern on the strip\n     * @param startHue the starting hue value (0-360)\n     * @param length the length of the gradient in number of LEDs\n     * @param fromColor starting color of the gradient\n     * @param toColor ending color of the gradient\n     */\n    //% subcategory=\"Prime\"\n    //% value.defl=\"#FFFFFF\"\n    //% group=\"Neo_Color\"\n    //% blockId=\"one_bit_prime_gradient\"\n    //% block=\"show gradient with start hue %startHue|length %length|from %fromColor|to %toColor\"\n    //% weight=90 blockGap=8\n    //% fromColor.shadow=\"brightColorNumberPicker\" \n    //% toColor.shadow=\"brightColorNumberPicker\"\n    export function showPrimeGradient(startHue: number, length: number, fromColor: number, toColor: number): void {\n        for (let i = 0; i < length; i++) {\n            let blendColor = blend(fromColor, toColor, i / length);\n            setLedColor(i, blendColor); // Custom function to set LED color\n        }\n        updateLeds(); // Custom function to apply changes\n    }\n\n\n    /**\n     * Helper function to blend two colors\n     * @param color1 the first color\n     * @param color2 the second color\n     * @param blend the blend factor between the two colors (0-1)\n     */\n    function blend(color1: number, color2: number, blend: number): number {\n        let r1 = (color1 >> 16) & 0xFF;\n        let g1 = (color1 >> 8) & 0xFF;\n        let b1 = color1 & 0xFF;\n\n        let r2 = (color2 >> 16) & 0xFF;\n        let g2 = (color2 >> 8) & 0xFF;\n        let b2 = color2 & 0xFF;\n\n        let r = Math.round(r1 * (1 - blend) + r2 * blend);\n        let g = Math.round(g1 * (1 - blend) + g2 * blend);\n        let b = Math.round(b1 * (1 - blend) + b2 * blend);\n\n        return (r << 16) | (g << 8) | b;\n    }\n\n\n\n    /**\n     * Custom color picker with all specified colors\n     */\n    //% subcategory=\"Prime\"\n    //% value.defl='#CCFF00'\n    //% group=\"Neo_Color\"\n    //% weight=80 blockGap=20\n    //% blockId=brightColorNumberPicker block=\"%value\"\n    //% shim=TD_ID colorSecondary=\"#FFFFFF\"\n    //% value.fieldEditor=\"colornumber\" value.fieldOptions.decompileLiterals=true\n    //% value.fieldOptions.colours='[\"#CCFF00\",\"#CCCC00\",\"#CC9900\",\"#CC6600\",\"#CC3300\",\"#CC0000\",\"#660000\",\"#663300\",\"#666600\",\"#669900\",\"#66CC00\",\"#66FF00\",\"#00FF00\",\"#00CC00\",\"#009900\",\"#006600\",\"#003300\",\"#000000\",\"#CCFF33\",\"#CCCC33\",\"#CC9933\",\"#CC6633\",\"#CC3333\",\"#CC0033\",\"#660033\",\"#663333\",\"#666633\",\"#669933\",\"#66CC33\",\"#66FF33\",\"#00FF33\",\"#00CC33\",\"#009933\",\"#006633\",\"#003333\",\"#000033\",\"#CCFF66\",\"#CCCC66\",\"#CC9966\",\"#CC6666\",\"#CC3366\",\"#CC0066\",\"#660066\",\"#663366\",\"#666666\",\"#669966\",\"#66CC66\",\"#66FF66\",\"#00FF66\",\"#00CC66\",\"#009966\",\"#006666\",\"#003366\",\"#000066\",\"#CCFF99\",\"#CCCC99\",\"#CC9999\",\"#CC6699\",\"#CC3399\",\"#CC0099\",\"#660099\",\"#663399\",\"#666699\",\"#669999\",\"#66CC99\",\"#66FF99\",\"#00FF99\",\"#00CC99\",\"#009999\",\"#006699\",\"#003399\",\"#000099\",\"#CCFFCC\",\"#CCCCCC\",\"#CC99CC\",\"#CC66CC\",\"#CC33CC\",\"#CC00CC\",\"#6600CC\",\"#6633CC\",\"#6666CC\",\"#6699CC\",\"#66CCCC\",\"#66FFCC\",\"#00FFCC\",\"#00CCCC\",\"#0099CC\",\"#0066CC\",\"#0033CC\",\"#0000CC\",\"#CCFFFF\",\"#CCCCFF\",\"#CC99FF\",\"#CC66FF\",\"#CC33FF\",\"#CC00FF\",\"#6600FF\",\"#6633FF\",\"#6666FF\",\"#6699FF\",\"#66CCFF\",\"#66FFFF\",\"#00FFFF\",\"#00CCFF\",\"#0099FF\",\"#0066FF\",\"#0033FF\",\"#0000FF\",\"#FFFFFF\",\"#FFCCFF\",\"#FF99FF\",\"#FF66FF\",\"#FF33FF\",\"#FF00FF\",\"#9900FF\",\"#9933FF\",\"#9966FF\",\"#9999FF\",\"#99CCFF\",\"#99FFFF\",\"#33FFFF\",\"#33CCFF\",\"#3399FF\",\"#3366FF\",\"#3333FF\",\"#3300FF\",\"#FFFFCC\",\"#FFCCCC\",\"#FF99CC\",\"#FF66CC\",\"#FF33CC\",\"#FF00CC\",\"#9900CC\",\"#9933CC\",\"#9966CC\",\"#9999CC\",\"#99CCCC\",\"#99FFCC\",\"#33FFCC\",\"#33CCCC\",\"#3399CC\",\"#3366CC\",\"#3333CC\",\"#3300CC\",\"#FFFF99\",\"#FFCC99\",\"#FF9999\",\"#FF6699\",\"#FF3399\",\"#FF0099\",\"#990099\",\"#993399\",\"#996699\",\"#999999\",\"#99CC99\",\"#99FF99\",\"#33FF99\",\"#33CC99\",\"#339999\",\"#336699\",\"#333399\",\"#330099\",\"#FFFF66\",\"#FFCC66\",\"#FF9966\",\"#FF6666\",\"#FF3366\",\"#FF0066\",\"#990066\",\"#993366\",\"#996666\",\"#999966\",\"#99CC66\",\"#99FF66\",\"#33FF66\",\"#33CC66\",\"#339966\",\"#336666\",\"#333366\",\"#330066\",\"#FFFF33\",\"#FFCC33\",\"#FF9933\",\"#FF6633\",\"#FF3333\",\"#FF0033\",\"#990033\",\"#993333\",\"#996633\",\"#999933\",\"#99CC33\",\"#99FF33\",\"#33FF33\",\"#33CC33\",\"#339933\",\"#336633\",\"#333333\",\"#330033\"]'\n    //% value.fieldOptions.columns=18 value.fieldOptions.className='rgbColorPicker'\n    export function __colorNumberPicker(value: number): number {\n        return value;\n    }\n\n\n    /**\n     * Get a random color\n     */\n    //% blockId=\"one_bit_prime_random_color\"\n    //% value.defl='#ff0000' \n    //% group=\"Neo_Color\" weight=70\n    //% block=\"random color\"\n    //% subcategory=\"Prime\"\n    export function primeRandomColor(): number {\n        return Math.randomRange(0, 0xFFFFFF);\n    }\n\n\n    /**\n     * Convert RGB values to a color number\n     * @param r Red value (0-255)\n     * @param g Green value (0-255)\n     * @param b Blue value (0-255)\n     */\n    //% blockId=\"one_bit_prime_rgb_to_color\"\n    //% value.defl='#ff0000' \n    //% group=\"Neo_Color\" weight=60\n    //% block=\"R %r|G %g|B %b\"\n    //% r.min=0 r.max=255\n    //% g.min=0 g.max=255\n    //% b.min=0 b.max=255\n    //% subcategory=\"Prime\"\n    export function primeRgbToColor(r: number, g: number, b: number): number {\n        return (r << 16) | (g << 8) | b;\n    }\n\n    /**\n     * Convert HSL values to a color number\n     * @param h Hue (0-360)\n     * @param s Saturation (0-100)\n     * @param l Luminosity (0-100)\n     */\n    //% blockId=\"one_bit_prime_hsl_to_color\"\n    //% value.defl='#ff0000' \n    //% group=\"Neo_Color\" weight=50\n    //% block=\"hue %h|saturation %s|luminosity %l\"\n    //% h.min=0 h.max=360\n    //% s.min=0 s.max=100\n    //% l.min=0 l.max=100\n    //% subcategory=\"Prime\"\n    export function primeHslToColor(h: number, s: number, l: number): number {\n        return hslToRgb(h, s, l); // Custom function for HSL to RGB\n    }\n\n    /**\n * Convert HSL values to RGB\n * @param h Hue (0-360)\n * @param s Saturation (0-100)\n * @param l Luminosity (0-100)\n * @returns A packed RGB number (24-bit)\n */\n    function hslToRgb(h: number, s: number, l: number): number {\n        h = h % 360; // Ensure hue wraps around 360\n        s = s / 100; // Convert saturation to a decimal\n        l = l / 100; // Convert luminosity to a decimal\n\n        const c = (1 - Math.abs(2 * l - 1)) * s; // Chroma\n        const x = c * (1 - Math.abs((h / 60) % 2 - 1)); // Second largest component\n        const m = l - c / 2;\n\n        let r = 0, g = 0, b = 0;\n\n        if (h >= 0 && h < 60) {\n            r = c; g = x; b = 0;\n        } else if (h >= 60 && h < 120) {\n            r = x; g = c; b = 0;\n        } else if (h >= 120 && h < 180) {\n            r = 0; g = c; b = x;\n        } else if (h >= 180 && h < 240) {\n            r = 0; g = x; b = c;\n        } else if (h >= 240 && h < 300) {\n            r = x; g = 0; b = c;\n        } else if (h >= 300 && h < 360) {\n            r = c; g = 0; b = x;\n        }\n\n        // Convert RGB components to 8-bit values and pack into a single integer\n        const red = Math.round((r + m) * 255);\n        const green = Math.round((g + m) * 255);\n        const blue = Math.round((b + m) * 255);\n\n        return (red << 16) | (green << 8) | blue;\n    }\n\n\n    /**\n     * Custom function to set a specific LED's color\n     * @param index LED index\n     * @param color RGB color\n     */\n    function setLedColor(index: number, color: number): void {\n        // Send the appropriate signal to the LEDs\n        let r = (color >> 16) & 0xFF;\n        let g = (color >> 8) & 0xFF;\n        let b = color & 0xFF;\n\n        // Logic to send r, g, and b to the specific LED\n        sendSignalToLed(index, r, g, b);\n    }\n\n    /**\n     * Function to send RGB signal to a specific LED\n     */\n    function sendSignalToLed(index: number, r: number, g: number, b: number): void {\n        // Use custom bit-banging logic or timing logic here\n    }\n\n    /**\n     * Function to apply updates to the LEDs\n     */\n    function updateLeds(): void {\n        // Trigger any necessary latch or update commands for the LEDs\n    }\n\n\n\n    ////////////////////\n    // Sensors //\n    ////////////////////\n\n    // Enum for Distance Units\n    export enum Unit {\n        //% block=\"cm\"\n        Centimeters,\n        //% block=\"inches\"\n        Inches\n    }\n\n    /**\n     * Initialize Ultrasonic Sensor and get distance\n     * @param trigPin TRIG pin of the sensor\n     * @param echoPin ECHO pin of the sensor\n     * @param unit Desired distance unit\n     * @param maxCmDistance Maximum measurable distance in centimeters (default is 500)\n     */\n    //% blockId=\"initialize_and_get_ultrasonic_distance\" \n    //% block=\"ultrasonic on trig %trigPin|echo %echoPin|distance in %unit\"\n    //% subcategory=\"Sensors\"\n    //% group=\"Ultrasonic Sensor\"\n    //% trigPin.defl=PWM.P0\n    //% echoPin.defl=PWM.P1\n    //% unit.defl=Unit.Centimeters\n    //% weight=100 blockGap=8\n    export function initializeAndGetUltrasonicDistance(\n        trigPin: PWM,\n        echoPin: PWM,\n        unit: Unit,\n        maxCmDistance = 500\n    ): number {\n        // Send pulse to trigger ultrasonic sensor\n        pins.setPull(trigPin, PinPullMode.PullNone);\n        pins.digitalWritePin(trigPin, 0);\n        control.waitMicros(2);\n        pins.digitalWritePin(trigPin, 1);\n        control.waitMicros(10);\n        pins.digitalWritePin(trigPin, 0);\n\n        // Read pulse duration from echo pin\n        const d = pins.pulseIn(echoPin, PulseValue.High, maxCmDistance * 58);\n\n        // Handle case where no echo is received\n        if (d === 0) {\n            return -1; // Return -1 for no response\n        }\n\n        // Convert pulse duration to distance\n        switch (unit) {\n            case Unit.Centimeters:\n                return Math.idiv(d, 58); // Convert to cm\n            case Unit.Inches:\n                return Math.idiv(d, 148); // Convert to inches\n            default:\n                return -1;\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n\n\n    export enum tempUnit {\n        //% block=\"Celsius (*C)\"\n        celsius,\n        //% block=\"Fahrenheit (*F)\"\n        fahrenheit,\n    }\n\n    let _temperature: number = -999.0\n    let _humidity: number = -999.0\n\n    /**\n    * Read temperature data from DHT11 sensor.\n    * @param pin the pin number where the DHT11 data pin is connected\n    * @param unit the temperature unit to read (Celsius or Fahrenheit)\n    */\n    //% blockId=\"dht11_temperature\"\n    //% block=\"read Temperature on Pin $pin with Unit $unit\"\n    //% subcategory=\"Sensors\"\n    //% group=\"DHT11\"\n    //% pin.defl=DigitalPin.P0\n    //% unit.defl=celsius\n    export function readTemperature(pin: DigitalPin, unit: tempUnit): number {\n        // Initialize sensor and read data\n        let resultArray: number[] = []\n        let dataArray: boolean[] = []\n        let startTime = input.runningTimeMicros()\n\n        for (let i = 0; i < 40; i++) dataArray.push(false)\n        for (let i = 0; i < 5; i++) resultArray.push(0)\n\n        pins.digitalWritePin(pin, 0)\n        basic.pause(18)\n\n        pins.setPull(pin, PinPullMode.PullUp)\n        pins.digitalReadPin(pin)\n        control.waitMicros(40)\n\n        // Sensor response\n        if (pins.digitalReadPin(pin) == 0) {\n            while (pins.digitalReadPin(pin) == 0);\n            while (pins.digitalReadPin(pin) == 1);\n\n            // Read data\n            for (let i = 0; i < 40; i++) {\n                while (pins.digitalReadPin(pin) == 1);\n                while (pins.digitalReadPin(pin) == 0);\n                control.waitMicros(28)\n                if (pins.digitalReadPin(pin) == 1) dataArray[i] = true\n            }\n\n            // Convert byte data to integer\n            for (let i = 0; i < 5; i++)\n                for (let j = 0; j < 8; j++)\n                    if (dataArray[8 * i + j]) resultArray[i] += 2 ** (7 - j)\n\n            // Temperature and humidity values\n            _humidity = resultArray[0] + resultArray[1] / 100\n            _temperature = resultArray[2] + resultArray[3] / 100\n\n            // Convert to Fahrenheit if needed\n            if (unit == tempUnit.fahrenheit) {\n                _temperature = _temperature * 9 / 5 + 32\n            }\n        }\n\n        return _temperature\n    }\n\n    /**\n    * Read humidity data from DHT11 sensor.\n    * @param pin the pin number where the DHT11 data pin is connected\n    */\n    //% blockId=\"dht11_humidity\"\n    //% block=\"read Humidity on Pin $pin\"\n    //% subcategory=\"Sensors\"\n    //% group=\"DHT11\"\n    //% pin.defl=DigitalPin.P0\n    export function readHumidity(pin: DigitalPin): number {\n        // Initialize sensor and read data\n        let resultArray: number[] = []\n        let dataArray: boolean[] = []\n        let startTime = input.runningTimeMicros()\n\n        for (let i = 0; i < 40; i++) dataArray.push(false)\n        for (let i = 0; i < 5; i++) resultArray.push(0)\n\n        pins.digitalWritePin(pin, 0)\n        basic.pause(18)\n\n        pins.setPull(pin, PinPullMode.PullUp)\n        pins.digitalReadPin(pin)\n        control.waitMicros(40)\n\n        // Sensor response\n        if (pins.digitalReadPin(pin) == 0) {\n            while (pins.digitalReadPin(pin) == 0);\n            while (pins.digitalReadPin(pin) == 1);\n\n            // Read data\n            for (let i = 0; i < 40; i++) {\n                while (pins.digitalReadPin(pin) == 1);\n                while (pins.digitalReadPin(pin) == 0);\n                control.waitMicros(28)\n                if (pins.digitalReadPin(pin) == 1) dataArray[i] = true\n            }\n\n            // Convert byte data to integer\n            for (let i = 0; i < 5; i++)\n                for (let j = 0; j < 8; j++)\n                    if (dataArray[8 * i + j]) resultArray[i] += 2 ** (7 - j)\n\n            // Humidity value\n            _humidity = resultArray[0] + resultArray[1] / 100\n            _temperature = resultArray[2] + resultArray[3] / 100\n        }\n\n        return _humidity\n    }\n\n    //////////////////////////////////////////////////////////////////////////\n\n\n    /**\n     * Get the digital value from the IR sensor (1 for detection, 0 for no detection) on the selected pin.\n     * @param pin the digital pin where the IR sensor is connected\n     */\n    //% subcategory=\"Sensors\"\n    //% group=\"IR Sensor\"\n    //% blockId=\"ir_sensor_digital\"\n    //% block=\"ir Sensor on Digital Pin %pin\"\n    //% pin.defl=DigitalPinPrime.P0\n    //% weight=90 blockGap=20\n    export function readIRSensorDigital(pin: DigitalPinPrime): number {\n        // Read the current state of the pin\n        let rawValue = pins.digitalReadPin(pin);\n\n        // Invert the value since 0 means detected and 1 means not detected\n        let invertedValue = rawValue === 0 ? 1 : 0;\n\n        // Reset the pin state (pull back to neutral to avoid latch state)\n        pins.setPull(pin, PinPullMode.PullNone);\n\n        return invertedValue;\n    }\n\n\n\n    /**\n     * Get the analog value from the IR sensor on the selected pin.\n     * @param pin the analog pin where the IR sensor is connected\n     */\n    //% subcategory=\"Sensors\"\n    //% group=\"IR Sensor\"\n    //% blockId=\"ir_sensor_analog\"\n    //% block=\"ir Sensor on Analog Pin %pin\"\n    //% pin.defl=AnalogPinPrime.P0\n    //% weight=100 blockGap=20\n    export function readIRSensorAnalog(pin: AnalogPinPrime): number {\n        // Read the value from the specified analog pin\n        const value = pins.analogReadPin(pin);\n        return value; // Return the analog value (0-1023)\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n\n    // Function to get the digital value of the LDR sensor with reset\n    //% subcategory=\"Sensors\"\n    //% group=\"LDR Sensor\"\n    //% blockId=\"ldr_digital_value_reset\"\n    //% block=\"ldr Sensor on Digital Pin %pin\"\n    //% weight=180 blockGap=20\n    export function getLDRSensorDigitalValueReset(pin: DigitalPinPrime): number {\n        // Ensure the pin is set to input mode before reading\n        pins.setPull(pin, PinPullMode.PullNone);\n\n        // Read the digital value from the pin (either 0 or 1)\n        let value = pins.digitalReadPin(pin);\n\n        // Reset the pin state by reinitializing it as a digital input again\n        pins.setPull(pin, PinPullMode.PullNone); // Reset state by disabling pull-up/down\n\n        // Return the value (0 or 1)\n        return value;\n    }\n\n    // Function to read from an LDR sensor connected to an analog pin\n    //% subcategory=\"Sensors\"\n    //% group=\"LDR Sensor\"\n    //% blockId=\"ldr_analog_value\"\n    //% block=\"ldr Sensor on Analog Pin %pin\"\n    //% weight=180 blockGap=20\n    export function getLDRSensorAnalogValue(pin: AnalogPinPrime): number {\n        // Read and return the inverted analog value (1023 - value)\n        let sensorValue = pins.analogReadPin(pin);\n        return 1023 - sensorValue;  // Invert the value (higher value for dark, lower for light)\n    }\n\n\n\n    /////////////////////////////////////////////////////////////////////////\n\n    // Function to read the moisture sensor value\n    //% subcategory=\"Sensors\"\n    //% group=\"Moisture Sensor\"\n    //% blockId=\"moisture_sensor_value\"\n    //% block=\"moisture sensor value on Pin %pin\"\n    //% weight=180 blockGap=20\n    export function getMoistureSensorValue(pin: AnalogPinPrime): number {\n        // Read and return the analog value from the specified pin\n        return pins.analogReadPin(pin);\n    }\n\n\n    /////////////////////////////////////////////////////////////////////////\n    ////////////////////\n    //Actuators //\n    ////////////////////\n\n\n    // Convert any DigitalPinPrime to AnalogPin (for PWM control)\n    function getDigitalPin(pin: DigitalPinPrime): DigitalPin {\n        switch (pin) {\n            case DigitalPinPrime.P0: return DigitalPin.P0;\n            case DigitalPinPrime.P1: return DigitalPin.P1;\n            case DigitalPinPrime.P2: return DigitalPin.P2;\n            case DigitalPinPrime.P3: return DigitalPin.P3;\n            case DigitalPinPrime.P4: return DigitalPin.P4;\n            case DigitalPinPrime.P9: return DigitalPin.P9;\n            case DigitalPinPrime.P10: return DigitalPin.P10;\n            case DigitalPinPrime.P13: return DigitalPin.P13;\n            case DigitalPinPrime.P14: return DigitalPin.P14;\n            case DigitalPinPrime.P15: return DigitalPin.P15;\n            case DigitalPinPrime.P19: return DigitalPin.P19;\n            case DigitalPinPrime.P20: return DigitalPin.P20;\n            default: return DigitalPin.P0; // Fallback\n        }\n    }\n\n    // Define servo positions enumeration\n    export enum ServoPosition {\n        //% block=\"0 degrees\"\n        Zero = 0,\n        //% block=\"45 degrees\"\n        FortyFive = 45,\n        //% block=\"90 degrees\"\n        Ninety = 90,\n        //% block=\"135 degrees\"\n        OneThirtyFive = 135,\n        //% block=\"180 degrees\"\n        OneEighty = 180\n    }\n\n\n    /**\n    * Moves a servo to a specified position.\n    * @param pin which pin to control\n    * @param position the position to move to\n    */\n    //% subcategory=\"Actuators\"\n    //% weight=150 blockGap=8\n    //% group=\"Positional Servo\"\n    //% blockId=\"move_positional_servo\"\n    //% block=\"move servo on pin %pin|to position %position\"\n    //% position.min=0 position.max=180\n    export function movePositionalServo(pin: DigitalPinPrime, position: number): void {\n        const angle = Math.clamp(0, 180, position);  // Ensure angle is within 0-180 range\n        pins.servoWritePin(getDigitalPin(pin), angle);\n    }\n\n    /**\n     * Moves a servo to a specified position.\n     * @param pin which pin to control\n     * @param position the position to move to\n     */\n    //% subcategory=\"Actuators\"\n    //% weight=120 blockGap=8\n    //% group=\"Positional Servo\"\n    //% blockId=\"move_positional_servo_to_fixed_point\"\n    //% block=\"move servo on pin %pin|to position %position\"\n    export function movePositionalServofixed(pin: DigitalPinPrime, position: ServoPosition): void {\n        // Using the ServoPosition enum, which already contains the angle values\n        pins.servoWritePin(getDigitalPin(pin), position);  // position is directly the angle in degrees\n    }\n\n    //% subcategory=\"Actuators\"\n    //% weight=10 blockGap=8\n    //% group=\"Positional Servo\" \n    //% blockId=\"move_servo_from_to\"\n    //% block=\"move servo on pin %pin|from angle %from|to angle %to|over %duration seconds\"\n    //% from.min=0 from.max=180\n    //% to.min=0 to.max=180\n    //% duration.min=1 duration.max=10\n    export function moveServoFromTo1(pin: DigitalPinPrime, from: number, to: number, duration: number): void {\n        const startAngle = Math.clamp(0, 180, from);\n        const endAngle = Math.clamp(0, 180, to);\n        const steps = Math.abs(endAngle - startAngle);\n        const stepDuration = duration * 1000 / steps;\n\n        // Loop through each step and move the servo\n        for (let i = 0; i <= steps; i++) {\n            // Calculate the current angle for the servo based on the direction of movement\n            const currentAngle = startAngle + (endAngle > startAngle ? i : -i);\n\n            // Ensure that we don't exceed the target angle, especially when rounding\n            if ((endAngle > startAngle && currentAngle >= endAngle) || (endAngle < startAngle && currentAngle <= endAngle)) {\n                // Set the final angle to the target and break the loop\n                pins.servoWritePin(getDigitalPin(pin), endAngle);\n                break; // exit the loop once we reach the target angle\n            } else {\n                // Otherwise, move the servo to the current calculated angle\n                pins.servoWritePin(getDigitalPin(pin), currentAngle);\n            }\n\n            // Pause for the time before moving to the next step\n            basic.pause(stepDuration);\n        }\n    }\n\n    /**\n     * Controls the speed and direction of a continuous rotation servo.\n     * @param pin which pin to control\n     * @param speed the speed of the servo motor (-100 to 100)\n     */\n    //% subcategory=\"Actuators\"\n    //% weight=40 blockGap=8\n    //% group=\"Continuous Servo\"\n    //% blockId=\"move_continuous_servo\"\n    //% block=\"set continuous servo on pin %pin|to speed %speed\"\n    //% speed.min=-100 speed.max=100\n    export function moveContinuousServo(pin: DigitalPinPrime, speed: number): void {\n        const speedValue = Math.clamp(-100, 100, speed);  // Ensure speed is within -100 to 100 range\n\n        // Map speed to the correct PWM values (using -100 for full reverse and 100 for full forward)\n        const pwmValue = Math.map(speedValue, -100, 100, 0, 180);  // 40-120 range typically works for continuous servos\n\n        // Write the PWM value to the pin\n        pins.servoWritePin(getDigitalPin(pin), pwmValue);\n    }\n\n\n    /**\n     * Stops the continuous rotation servo.\n     * @param pin which pin to control\n     */\n    //% subcategory=\"Actuators\"\n    //% weight=30 blockGap=8\n    //% group=\"Continuous Servo\"\n    //% blockId=\"stop_continuous_servo\"\n    //% block=\"stop continuous servo on pin %pin\"\n    export function stopContinuousServo(pin: DigitalPinPrime): void {\n        // Set speed to 0 to stop the motor\n        pins.servoWritePin(getDigitalPin(pin), 90);  // 90 typically stops a continuous servo\n    }\n\n\n    /////////////////////////////////////////////////////////////////////////\n\n\n    declare interface Math {\n        floor(x: number): number;\n    }\n    let font: Buffer;\n    const SSD1306_SETCONTRAST = 0x81\n    const SSD1306_SETCOLUMNADRESS = 0x21\n    const SSD1306_SETPAGEADRESS = 0x22\n    const SSD1306_DISPLAYALLON_RESUME = 0xA4\n    const SSD1306_DISPLAYALLON = 0xA5\n    const SSD1306_NORMALDISPLAY = 0xA6\n    const SSD1306_INVERTDISPLAY = 0xA7\n    const SSD1306_DISPLAYOFF = 0xAE\n    const SSD1306_DISPLAYON = 0xAF\n    const SSD1306_SETDISPLAYOFFSET = 0xD3\n    const SSD1306_SETCOMPINS = 0xDA\n    const SSD1306_SETVCOMDETECT = 0xDB\n    const SSD1306_SETDISPLAYCLOCKDIV = 0xD5\n    const SSD1306_SETPRECHARGE = 0xD9\n    const SSD1306_SETMULTIPLEX = 0xA8\n    const SSD1306_SETLOWCOLUMN = 0x00\n    const SSD1306_SETHIGHCOLUMN = 0x10\n    const SSD1306_SETSTARTLINE = 0x40\n    const SSD1306_MEMORYMODE = 0x20\n    const SSD1306_COMSCANINC = 0xC0\n    const SSD1306_COMSCANDEC = 0xC8\n    const SSD1306_SEGREMAP = 0xA0\n    const SSD1306_CHARGEPUMP = 0x8D\n    const chipAdress = 0x3C\n    const xOffset = 0\n    const yOffset = 0\n    let charX = 0\n    let charY = 0\n    let displayWidth = 128\n    let displayHeight = 64 / 8\n    let screenSize = 0\n\n    //let font: Array<Array<number>>\n    let loadStarted: boolean;\n    let loadPercent: number;\n    function command(cmd: number) {\n        let buf = pins.createBuffer(2)\n        buf[0] = 0x00\n        buf[1] = cmd\n        pins.i2cWriteBuffer(chipAdress, buf, false)\n    }\n\n\n    //% subcategory=\"Actuators\"\n    //% group=\"OLED\"\n    //% block=\"initialize OLED with width $width height $height\"\n    //% width.defl=128\n    //% height.defl=64\n    //% weight=150\n    export function init(width: number, height: number) {\n        command(SSD1306_DISPLAYOFF);\n        command(SSD1306_SETDISPLAYCLOCKDIV);\n        command(0x80);                                  // the suggested ratio 0x80\n        command(SSD1306_SETMULTIPLEX);\n        command(0x3F);\n        command(SSD1306_SETDISPLAYOFFSET);\n        command(0x0);                                   // no offset\n        command(SSD1306_SETSTARTLINE | 0x0);            // line #0\n        command(SSD1306_CHARGEPUMP);\n        command(0x14);\n        command(SSD1306_MEMORYMODE);\n        command(0x00);                                  // 0x0 act like ks0108\n        command(SSD1306_SEGREMAP | 0x1);\n        command(SSD1306_COMSCANDEC);\n        command(SSD1306_SETCOMPINS);\n        command(0x12);\n        command(SSD1306_SETCONTRAST);\n        command(0xCF);\n        command(SSD1306_SETPRECHARGE);\n        command(0xF1);\n        command(SSD1306_SETVCOMDETECT);\n        command(0x40);\n        command(SSD1306_DISPLAYALLON_RESUME);\n        command(SSD1306_NORMALDISPLAY);\n        command(SSD1306_DISPLAYON);\n        displayWidth = width\n        displayHeight = height / 8\n        screenSize = displayWidth * displayHeight\n        charX = xOffset\n        charY = yOffset\n        font = hex`\n    0000000000\n    3E5B4F5B3E\n    3E6B4F6B3E\n    1C3E7C3E1C\n    183C7E3C18\n    1C577D571C\n    1C5E7F5E1C\n    00183C1800\n    FFE7C3E7FF\n    0018241800\n    FFE7DBE7FF\n    30483A060E\n    2629792926\n    407F050507\n    407F05253F\n    5A3CE73C5A\n    7F3E1C1C08\n    081C1C3E7F\n    14227F2214\n    5F5F005F5F\n    06097F017F\n    006689956A\n    6060606060\n    94A2FFA294\n    08047E0408\n    10207E2010\n    08082A1C08\n    081C2A0808\n    1E10101010\n    0C1E0C1E0C\n    30383E3830\n    060E3E0E06\n    0000000000\n    00005F0000\n    0007000700\n    147F147F14\n    242A7F2A12\n    2313086462\n    3649562050\n    0008070300\n    001C224100\n    0041221C00\n    2A1C7F1C2A\n    08083E0808\n    0080703000\n    0808080808\n    0000606000\n    2010080402\n    3E5149453E\n    00427F4000\n    7249494946\n    2141494D33\n    1814127F10\n    2745454539\n    3C4A494931\n    4121110907\n    3649494936\n    464949291E\n    0000140000\n    0040340000\n    0008142241\n    1414141414\n    0041221408\n    0201590906\n    3E415D594E\n    7C1211127C\n    7F49494936\n    3E41414122\n    7F4141413E\n    7F49494941\n    7F09090901\n    3E41415173\n    7F0808087F\n    00417F4100\n    2040413F01\n    7F08142241\n    7F40404040\n    7F021C027F\n    7F0408107F\n    3E4141413E\n    7F09090906\n    3E4151215E\n    7F09192946\n    2649494932\n    03017F0103\n    3F4040403F\n    1F2040201F\n    3F4038403F\n    6314081463\n    0304780403\n    6159494D43\n    007F414141\n    0204081020\n    004141417F\n    0402010204\n    4040404040\n    0003070800\n    2054547840\n    7F28444438\n    3844444428\n    384444287F\n    3854545418\n    00087E0902\n    18A4A49C78\n    7F08040478\n    00447D4000\n    2040403D00\n    7F10284400\n    00417F4000\n    7C04780478\n    7C08040478\n    3844444438\n    FC18242418\n    18242418FC\n    7C08040408\n    4854545424\n    04043F4424\n    3C4040207C\n    1C2040201C\n    3C4030403C\n    4428102844\n    4C9090907C\n    4464544C44\n    0008364100\n    0000770000\n    0041360800\n    0201020402\n    3C2623263C\n    1EA1A16112\n    3A4040207A\n    3854545559\n    2155557941\n    2154547841\n    2155547840\n    2054557940\n    0C1E527212\n    3955555559\n    3954545459\n    3955545458\n    0000457C41\n    0002457D42\n    0001457C40\n    F0292429F0\n    F0282528F0\n    7C54554500\n    2054547C54\n    7C0A097F49\n    3249494932\n    3248484832\n    324A484830\n    3A4141217A\n    3A42402078\n    009DA0A07D\n    3944444439\n    3D4040403D\n    3C24FF2424\n    487E494366\n    2B2FFC2F2B\n    FF0929F620\n    C0887E0903\n    2054547941\n    0000447D41\n    3048484A32\n    384040227A\n    007A0A0A72\n    7D0D19317D\n    2629292F28\n    2629292926\n    30484D4020\n    3808080808\n    0808080838\n    2F10C8ACBA\n    2F102834FA\n    00007B0000\n    08142A1422\n    22142A1408\n    AA005500AA\n    AA55AA55AA\n    000000FF00\n    101010FF00\n    141414FF00\n    1010FF00FF\n    1010F010F0\n    141414FC00\n    1414F700FF\n    0000FF00FF\n    1414F404FC\n    141417101F\n    10101F101F\n    1414141F00\n    101010F000\n    0000001F10\n    1010101F10\n    101010F010\n    000000FF10\n    1010101010\n    101010FF10\n    000000FF14\n    0000FF00FF\n    00001F1017\n    0000FC04F4\n    1414171017\n    1414F404F4\n    0000FF00F7\n    1414141414\n    1414F700F7\n    1414141714\n    10101F101F\n    141414F414\n    1010F010F0\n    00001F101F\n    0000001F14\n    000000FC14\n    0000F010F0\n    1010FF10FF\n    141414FF14\n    1010101F00\n    000000F010\n    FFFFFFFFFF\n    F0F0F0F0F0\n    FFFFFF0000\n    000000FFFF\n    0F0F0F0F0F\n    3844443844\n    7C2A2A3E14\n    7E02020606\n    027E027E02\n    6355494163\n    3844443C04\n    407E201E20\n    06027E0202\n    99A5E7A599\n    1C2A492A1C\n    4C7201724C\n    304A4D4D30\n    3048784830\n    BC625A463D\n    3E49494900\n    7E0101017E\n    2A2A2A2A2A\n    44445F4444\n    40514A4440\n    40444A5140\n    0000FF0103\n    E080FF0000\n    08086B6B08\n    3612362436\n    060F090F06\n    0000181800\n    0000101000\n    3040FF0101\n    001F01011E\n    00191D1712\n    003C3C3C3C\n    0000000000`\n        loadStarted = false\n        loadPercent = 0\n        clear()\n    }\n\n\n    // Clear the OLED screen\n    /**\n     * Clears everything displayed on the OLED screen, leaving it blank and ready for new content.\n     */\n    //% subcategory=\"Actuators\"\n    //% blockId=\"one_bit_prime_clear_screen\"\n    //% group=\"OLED\"\n    //% block=\"clear OLED display\"\n    //% weight=130 blockGap=8\n    export function clear() {\n        loadStarted = false\n        loadPercent = 0\n        command(SSD1306_SETCOLUMNADRESS)\n        command(0x00)\n        command(displayWidth - 1)\n        command(SSD1306_SETPAGEADRESS)\n        command(0x00)\n        command(displayHeight - 1)\n        let data = pins.createBuffer(17);\n        data[0] = 0x40; // Data Mode\n        for (let i = 1; i < 17; i++) {\n            data[i] = 0x00\n        }\n        // send display buffer in 16 byte chunks\n        for (let i = 0; i < screenSize; i += 16) {\n            pins.i2cWriteBuffer(chipAdress, data, false)\n        }\n        charX = xOffset\n        charY = yOffset\n    }\n\n\n    // Show string at x and y coordinates\n    /**\n     * Displays a string at the specified x and y coordinates on the OLED display.\n     * If the string exceeds the width of the screen, it will continue on the next line.\n     */\n    //% subcategory=\"Actuators\"\n    //% blockId=\"one_bit_prime_write_string\"\n    //% group=\"OLED\"\n    //% block=\"show string at x: $x y: $y with text $str\"\n    //% x.defl=0\n    //% y.defl=0\n    //% weight=120 blockGap=8\n    export function writeStringAt(x: number, y: number, str: string) {\n        let originalX = charX;\n        let originalY = charY;\n        charX = x;\n        charY = y;\n\n        for (let i = 0; i < str.length; i++) {\n            if (charX > displayWidth - 6) {\n                newLine();\n            }\n            drawChar(charX, charY, str.charAt(i));\n            charX += 6;\n        }\n\n        // Reset the cursor back to the original position\n        charX = originalX;\n        charY = originalY;\n    }\n\n    // Show number at x and y coordinates\n    /**\n     * Displays a number at the specified x and y coordinates on the OLED display.\n     * The number is converted to a string before being displayed.\n     */\n    //% subcategory=\"Actuators\"\n    //% blockId=\"one_bit_prime_write_number\"\n    //% group=\"OLED\"\n    //% block=\"show number $n at x: $x y: $y\"\n    //% weight=110 blockGap=8\n    export function writeNumAt(x: number, y: number, n: number) {\n        let numString = n.toString();  // Convert the number to a string\n        let charX = x;  // Starting X coordinate\n        let charY = y;  // Starting Y coordinate\n\n        // Loop through each character of the number string and display it at the coordinates\n        for (let i = 0; i < numString.length; i++) {\n            if (charX > displayWidth - 6) {\n                newLine();\n            }\n            drawChar(charX, charY, numString.charAt(i));\n            charX += 6;  // Move to the next character position\n        }\n    }\n\n    function newLine() {\n        charY++\n        charX = xOffset\n    }\n    function drawChar(x: number, y: number, c: string) {\n        command(SSD1306_SETCOLUMNADRESS)\n        command(x)\n        command(x + 5)\n        command(SSD1306_SETPAGEADRESS)\n        command(y)\n        command(y + 1)\n        let line = pins.createBuffer(2)\n        line[0] = 0x40\n        for (let i = 0; i < 6; i++) {\n            if (i === 5) {\n                line[1] = 0x00\n            } else {\n                let charIndex = c.charCodeAt(0)\n                let charNumber = font.getNumber(NumberFormat.UInt8BE, 5 * charIndex + i)\n                line[1] = charNumber\n\n            }\n            pins.i2cWriteBuffer(chipAdress, line, false)\n        }\n\n    }\n    function drawShape(pixels: Array<Array<number>>) {\n        let x1 = displayWidth\n        let y1 = displayHeight * 8\n        let x2 = 0\n        let y2 = 0\n        for (let i = 0; i < pixels.length; i++) {\n            if (pixels[i][0] < x1) {\n                x1 = pixels[i][0]\n            }\n            if (pixels[i][0] > x2) {\n                x2 = pixels[i][0]\n            }\n            if (pixels[i][1] < y1) {\n                y1 = pixels[i][1]\n            }\n            if (pixels[i][1] > y2) {\n                y2 = pixels[i][1]\n            }\n        }\n        let page1 = Math.floor(y1 / 8)\n        let page2 = Math.floor(y2 / 8)\n        let line = pins.createBuffer(2)\n        line[0] = 0x40\n        for (let x = x1; x <= x2; x++) {\n            for (let page = page1; page <= page2; page++) {\n                line[1] = 0x00\n                for (let i = 0; i < pixels.length; i++) {\n                    if (pixels[i][0] === x) {\n                        if (Math.floor(pixels[i][1] / 8) === page) {\n                            line[1] |= Math.pow(2, (pixels[i][1] % 8))\n                        }\n                    }\n                }\n                if (line[1] !== 0x00) {\n                    command(SSD1306_SETCOLUMNADRESS)\n                    command(x)\n                    command(x + 1)\n                    command(SSD1306_SETPAGEADRESS)\n                    command(page)\n                    command(page + 1)\n                    //line[1] |= pins.i2cReadBuffer(chipAdress, 2)[1]\n                    pins.i2cWriteBuffer(chipAdress, line, false)\n                }\n            }\n        }\n    }\n\n\n    // Draw a line from (x0, y0) to (x1, y1)\n    /**\n     * Draws a line between the two specified points on the OLED screen.\n     * The line is drawn using Bresenham's line algorithm.\n     */\n    //% subcategory=\"Actuators\"\n    //% blockId=\"one_bit_prime_draw_line\"\n    //% group=\"OLED\"\n    //% block=\"draw line from:|x: $x0 y: $y0 to| x: $x1 y: $y1\"\n    //% x0.defl=0\n    //% y0.defl=0\n    //% x1.defl=20\n    //% y1.defl=20\n    //% weight=100 blockGap=8\n    export function drawLine(x0: number, y0: number, x1: number, y1: number) {\n        let pixels: Array<Array<number>> = []\n        let kx: number, ky: number, c: number, i: number, xx: number, yy: number, dx: number, dy: number;\n        let targetX = x1\n        let targetY = y1\n        x1 -= x0; kx = 0; if (x1 > 0) kx = +1; if (x1 < 0) { kx = -1; x1 = -x1; } x1++;\n        y1 -= y0; ky = 0; if (y1 > 0) ky = +1; if (y1 < 0) { ky = -1; y1 = -y1; } y1++;\n        if (x1 >= y1) {\n            c = x1\n            for (i = 0; i < x1; i++, x0 += kx) {\n                pixels.push([x0, y0])\n                c -= y1; if (c <= 0) { if (i != x1 - 1) pixels.push([x0 + kx, y0]); c += x1; y0 += ky; if (i != x1 - 1) pixels.push([x0, y0]); }\n                if (pixels.length > 20) {\n                    drawShape(pixels)\n                    pixels = []\n                    drawLine(x0, y0, targetX, targetY)\n                    return\n                }\n            }\n        } else {\n            c = y1\n            for (i = 0; i < y1; i++, y0 += ky) {\n                pixels.push([x0, y0])\n                c -= x1; if (c <= 0) { if (i != y1 - 1) pixels.push([x0, y0 + ky]); c += y1; x0 += kx; if (i != y1 - 1) pixels.push([x0, y0]); }\n                if (pixels.length > 20) {\n                    drawShape(pixels)\n                    pixels = []\n                    drawLine(x0, y0, targetX, targetY)\n                    return\n                }\n            }\n        }\n        drawShape(pixels)\n    }\n\n    /**\n     * Draws a rectangle on the OLED display from the starting point (x0, y0) to the end point (x1, y1).\n     * The rectangle is drawn by drawing four lines: top, bottom, left, and right.\n     */\n    //% subcategory=\"Actuators\"\n    //% blockId=\"one_bit_prime_draw_rectangle\"\n    //% group=\"OLED\"\n    //% block=\"draw rectangle from:|x: $x0 y: $y0 to| x: $x1 y: $y1\"\n    //% x0.defl=0\n    //% y0.defl=0\n    //% x1.defl=20\n    //% y1.defl=20\n    //% weight=90 blockGap=8\n    export function drawRectangle(x0: number, y0: number, x1: number, y1: number) {\n        drawLine(x0, y0, x1, y0)\n        drawLine(x0, y1, x1, y1)\n        drawLine(x0, y0, x0, y1)\n        drawLine(x1, y0, x1, y1)\n    }\n\n\n    // Draw a circle at (x, y) with radius r\n    /**\n     * Draws a circle at the specified coordinates (x, y) with the given radius.\n     * The circle is drawn by plotting points along the circumference.\n     */\n    //% subcategory=\"Actuators\"\n    //% blockId=\"one_bit_prime_draw_circle\"\n    //% group=\"OLED\"\n    //% block=\"draw circle at x: $x y: $y radius: $r\"\n    //% x.defl=64\n    //% y.defl=32\n    //% r.defl=10\n    //% weight=80 blockGap=8\n    export function drawCircle(x: number, y: number, r: number) {\n        let theta = 0;\n        let step = Math.PI / 90;  // Adjust step for smoothness\n        let pixels: Array<Array<number>> = [];\n\n        while (theta < 2 * Math.PI) {\n            let xPos = Math.floor(x + r * Math.cos(theta));\n            let yPos = Math.floor(y + r * Math.sin(theta));\n            pixels.push([xPos, yPos]);\n            theta += step;\n        }\n\n        drawShape(pixels);\n    }\n\n\n    ///////////////////////////////////////////////////////////////////////////\n\n\n    ////////////////////\n    //  Rainbow BLOCKS  //\n    ////////////////////\n\n    let rainbowBuffer: Buffer = null; // LED data buffer\n    let rainbowNumLeds: number = 24;  // Number of LEDs\n    let rainbowBrightness: number = 255; // Default brightness\n\n\n    /**\n     * Initialize the Rainbow strip\n     * @param numLeds number of LEDs in the strip\n     */\n\n    //% blockId=\"rainbow_initialize\"\n    //% subcategory=\"Rainbow\"\n    //% block=\"initialize Rainbow with %numLeds|LEDs\"\n    //% weight=145 blockGap=8\n    export function initializeRainbow(numLeds: number): void {\n        rainbowNumLeds = numLeds;\n        rainbowBuffer = control.createBuffer(numLeds * 3);\n        clearRainbow(); // Ensure all LEDs start off\n    }\n\n\n\n    /**\n     * Show data on the Rainbow LEDs connected to P2\n    */\n    function showRainbowBuffer(): void {\n        if (rainbowBuffer) {\n            light.sendWS2812Buffer(rainbowBuffer, DigitalPin.P2); // Using P2 for Rainbow connection\n        }\n    }\n\n\n    /**\n     * Show rainbow colors on the strip\n     */\n    //% subcategory=\"Rainbow\"\n    //% blockId=\"rainbow_show_rainbow\"\n    //% block=\"show Rainbow\"\n    //% weight=140 blockGap=8\n    export function showRainbow(): void {\n        if (rainbowBuffer) {\n            for (let i = 0; i < rainbowNumLeds; i++) {\n                let angle = (i / rainbowNumLeds) * 2 * Math.PI;\n                let red = Math.max(0, Math.sin(angle + (1 / 3) * Math.PI) * 127 + 128);\n                let green = Math.max(0, Math.sin(angle + (2 / 3) * Math.PI) * 127 + 128);\n                let blue = Math.max(0, Math.sin(angle + (4 / 3) * Math.PI) * 127 + 128);\n                setRainbowLedColorRaw(i, Math.floor(red), Math.floor(green), Math.floor(blue));\n            }\n            showRainbowBuffer();\n        }\n    }\n\n    /**\n     * Clear all LEDs on the strip\n     */\n    //% subcategory=\"Rainbow\"\n    //% blockId=\"rainbow_clear\"\n    //% block=\"clear Rainbow\"\n    //% weight=130 blockGap=8\n    export function clearRainbow(): void {\n        if (rainbowBuffer) {\n            rainbowBuffer.fill(0);\n            showRainbowBuffer();\n        }\n    }\n\n    /**\n     * Set color of all LEDs on the strip\n     * @param color the color to set\n     */\n    //% subcategory=\"Rainbow\"\n    //% value.defl='#ff0000'\n    //% blockId=\"rainbow_set_color\"\n    //% block=\"set Rainbow color to %color\"\n    //% weight=120 blockGap=8\n    //% color.shadow=\"brightColorNumberPicker\"\n    export function setRainbowColor(color: number): void {\n        let red = (color >> 16) & 0xFF;\n        let green = (color >> 8) & 0xFF;\n        let blue = color & 0xFF;\n        for (let i = 0; i < rainbowNumLeds; i++) {\n            setRainbowLedColorRaw(i, red, green, blue);\n        }\n        showRainbowBuffer();\n    }\n\n    /**\n     * Set color of a specific LED on the strip\n     * @param ledIndex the index of the LED to change\n     * @param color the color to set\n     */\n    //% subcategory=\"Rainbow\"\n    //% value.defl='#ff0000'\n    //% blockId=\"rainbow_set_led_color\"\n    //% block=\"set Rainbow LED %ledIndex|color to %color\"\n    //% weight=110 blockGap=8\n    //% color.shadow=\"brightColorNumberPicker\"\n    export function setRainbowLedColor(ledIndex: number, color: number): void {\n        if (rainbowBuffer && ledIndex < rainbowNumLeds) {\n            let red = (color >> 16) & 0xFF;\n            let green = (color >> 8) & 0xFF;\n            let blue = color & 0xFF;\n\n            let index = ledIndex * 3; // Calculate position in buffer\n            rainbowBuffer.setUint8(index, (red * rainbowBrightness) >> 8); // Scale brightness\n            rainbowBuffer.setUint8(index + 1, (green * rainbowBrightness) >> 8); // Scale brightness\n            rainbowBuffer.setUint8(index + 2, (blue * rainbowBrightness) >> 8); // Scale brightness\n\n            showRainbowBuffer(); // Send updated buffer to the LEDs\n        }\n    }\n\n    /**\n     * Set brightness of the strip\n     * @param brightness brightness level (0-255)\n     */\n    //% subcategory=\"Rainbow\"\n    //% blockId=\"rainbow_set_brightness\"\n    //% block=\"set Rainbow brightness to %brightness\"\n    //% weight=100 blockGap=8\n    export function setRainbowBrightness(brightness: number): void {\n        rainbowBrightness = Math.clamp(0, 255, brightness);\n        applyRainbowBrightness(); // Apply brightness scaling to the buffer\n        showRainbowBuffer(); // Update LEDs with adjusted brightness\n    }\n\n    /**\n     * Apply brightness scaling to the buffer\n     */\n    function applyRainbowBrightness(): void {\n        if (!rainbowBuffer) return;\n\n        for (let i = 0; i < rainbowNumLeds; i++) {\n            let index = i * 3;\n            rainbowBuffer[index] = (rainbowBuffer[index] * rainbowBrightness) >> 8; // Scale Green\n            rainbowBuffer[index + 1] = (rainbowBuffer[index + 1] * rainbowBrightness) >> 8; // Scale Red\n            rainbowBuffer[index + 2] = (rainbowBuffer[index + 2] * rainbowBrightness) >> 8; // Scale Blue\n        }\n    }\n\n    /**\n     * Set color of a specific LED using raw RGB values\n     * @param ledIndex the index of the LED to change\n     * @param red Red value (0-255)\n     * @param green Green value (0-255)\n     * @param blue Blue value (0-255)\n     */\n    function setRainbowLedColorRaw(index: number, red: number, green: number, blue: number): void {\n        if (!rainbowBuffer || index >= rainbowNumLeds) return;\n\n        let brightnessScale = rainbowBrightness / 255; // Scale factor for brightness\n        rainbowBuffer[index * 3 + 0] = Math.floor(green * brightnessScale); // GRB: Green\n        rainbowBuffer[index * 3 + 1] = Math.floor(red * brightnessScale);   // GRB: Red\n        rainbowBuffer[index * 3 + 2] = Math.floor(blue * brightnessScale);  // GRB: Blue\n    }\n\n    /**\n     * Show a gradient pattern on the strip\n     * @param startHue the starting hue value (0-360)\n     * @param length the length of the gradient in number of LEDs\n     * @param fromColor starting color of the gradient\n     * @param toColor ending color of the gradient\n     */\n    //% subcategory=\"Rainbow\"\n    //% value.defl='#ff0000' \n    //% blockId=\"rainbow_gradient\"\n    //% block=\"show gradient with start hue %startHue|length %length|from %fromColor|to %toColor\"\n    //% weight=90 blockGap=8\n    //% fromColor.shadow=\"brightColorNumberPicker\" \n    //% toColor.shadow=\"brightColorNumberPicker\"\n    export function showRainbowGradient(startHue: number, length: number, fromColor: number, toColor: number): void {\n        for (let i = 0; i < length; i++) {\n            let blendColor = blendColors(fromColor, toColor, i / length);\n            setRainbowLedColor(i, blendColor); // Custom function to set LED color\n        }\n        showRainbowBuffer(); // Custom function to apply changes\n    }\n\n    /**\n     * Helper function to blend two colors\n     * @param color1 the first color\n     * @param color2 the second color\n     * @param blend the blend factor between the two colors (0-1)\n     */\n    function blendColors(color1: number, color2: number, blend: number): number {\n        let r1 = (color1 >> 16) & 0xFF;\n        let g1 = (color1 >> 8) & 0xFF;\n        let b1 = color1 & 0xFF;\n\n        let r2 = (color2 >> 16) & 0xFF;\n        let g2 = (color2 >> 8) & 0xFF;\n        let b2 = color2 & 0xFF;\n\n        let r = Math.round(r1 * (1 - blend) + r2 * blend);\n        let g = Math.round(g1 * (1 - blend) + g2 * blend);\n        let b = Math.round(b1 * (1 - blend) + b2 * blend);\n\n        return (r << 16) | (g << 8) | b;\n    }\n\n\n    /**\n     * Custom color picker with all specified colors\n     */\n    //% subcategory=\"Rainbow\"\n    //% value.defl='#CCFF00'\n    //% weight=80 blockGap=15\n    //% blockId=brightColorNumberPicker block=\"%value\"\n    //% shim=TD_ID colorSecondary=\"#FFFFFF\"\n    //% value.fieldEditor=\"colornumber\" value.fieldOptions.decompileLiterals=true\n    //% value.fieldOptions.colours='[\"#CCFF00\",\"#CCCC00\",\"#CC9900\",\"#CC6600\",\"#CC3300\",\"#CC0000\",\"#660000\",\"#663300\",\"#666600\",\"#669900\",\"#66CC00\",\"#66FF00\",\"#00FF00\",\"#00CC00\",\"#009900\",\"#006600\",\"#003300\",\"#000000\",\"#CCFF33\",\"#CCCC33\",\"#CC9933\",\"#CC6633\",\"#CC3333\",\"#CC0033\",\"#660033\",\"#663333\",\"#666633\",\"#669933\",\"#66CC33\",\"#66FF33\",\"#00FF33\",\"#00CC33\",\"#009933\",\"#006633\",\"#003333\",\"#000033\",\"#CCFF66\",\"#CCCC66\",\"#CC9966\",\"#CC6666\",\"#CC3366\",\"#CC0066\",\"#660066\",\"#663366\",\"#666666\",\"#669966\",\"#66CC66\",\"#66FF66\",\"#00FF66\",\"#00CC66\",\"#009966\",\"#006666\",\"#003366\",\"#000066\",\"#CCFF99\",\"#CCCC99\",\"#CC9999\",\"#CC6699\",\"#CC3399\",\"#CC0099\",\"#660099\",\"#663399\",\"#666699\",\"#669999\",\"#66CC99\",\"#66FF99\",\"#00FF99\",\"#00CC99\",\"#009999\",\"#006699\",\"#003399\",\"#000099\",\"#CCFFCC\",\"#CCCCCC\",\"#CC99CC\",\"#CC66CC\",\"#CC33CC\",\"#CC00CC\",\"#6600CC\",\"#6633CC\",\"#6666CC\",\"#6699CC\",\"#66CCCC\",\"#66FFCC\",\"#00FFCC\",\"#00CCCC\",\"#0099CC\",\"#0066CC\",\"#0033CC\",\"#0000CC\",\"#CCFFFF\",\"#CCCCFF\",\"#CC99FF\",\"#CC66FF\",\"#CC33FF\",\"#CC00FF\",\"#6600FF\",\"#6633FF\",\"#6666FF\",\"#6699FF\",\"#66CCFF\",\"#66FFFF\",\"#00FFFF\",\"#00CCFF\",\"#0099FF\",\"#0066FF\",\"#0033FF\",\"#0000FF\",\"#FFFFFF\",\"#FFCCFF\",\"#FF99FF\",\"#FF66FF\",\"#FF33FF\",\"#FF00FF\",\"#9900FF\",\"#9933FF\",\"#9966FF\",\"#9999FF\",\"#99CCFF\",\"#99FFFF\",\"#33FFFF\",\"#33CCFF\",\"#3399FF\",\"#3366FF\",\"#3333FF\",\"#3300FF\",\"#FFFFCC\",\"#FFCCCC\",\"#FF99CC\",\"#FF66CC\",\"#FF33CC\",\"#FF00CC\",\"#9900CC\",\"#9933CC\",\"#9966CC\",\"#9999CC\",\"#99CCCC\",\"#99FFCC\",\"#33FFCC\",\"#33CCCC\",\"#3399CC\",\"#3366CC\",\"#3333CC\",\"#3300CC\",\"#FFFF99\",\"#FFCC99\",\"#FF9999\",\"#FF6699\",\"#FF3399\",\"#FF0099\",\"#990099\",\"#993399\",\"#996699\",\"#999999\",\"#99CC99\",\"#99FF99\",\"#33FF99\",\"#33CC99\",\"#339999\",\"#336699\",\"#333399\",\"#330099\",\"#FFFF66\",\"#FFCC66\",\"#FF9966\",\"#FF6666\",\"#FF3366\",\"#FF0066\",\"#990066\",\"#993366\",\"#996666\",\"#999966\",\"#99CC66\",\"#99FF66\",\"#33FF66\",\"#33CC66\",\"#339966\",\"#336666\",\"#333366\",\"#330066\",\"#FFFF33\",\"#FFCC33\",\"#FF9933\",\"#FF6633\",\"#FF3333\",\"#FF0033\",\"#990033\",\"#993333\",\"#996633\",\"#999933\",\"#99CC33\",\"#99FF33\",\"#33FF33\",\"#33CC33\",\"#339933\",\"#336633\",\"#333333\",\"#330033\"]'\n    //% value.fieldOptions.columns=18 value.fieldOptions.className='rgbColorPicker'\n    export function rainbowColorPicker(value: number): number {\n        return value;\n    }\n\n    /**\n     * Get a random color\n     */\n    //% blockId=\"rainbow_random_color\"\n    //% value.defl='#ff0000' \n    //% weight=70 blockGap=15\n    //% block=\"random color\"\n    //% subcategory=\"Rainbow\"\n    export function rainbowRandomColor(): number {\n        return Math.randomRange(0, 0xFFFFFF);\n    }\n\n    /**\n     * Convert RGB values to a color number\n     * @param r Red value (0-255)\n     * @param g Green value (0-255)\n     * @param b Blue value (0-255)\n     */\n    //% blockId=\"rainbow_rgb_to_color\"\n    //% value.defl='#ff0000' \n    //% weight=60 blockGap=15\n    //% block=\"R %r|G %g|B %b\"\n    //% r.min=0 r.max=255\n    //% g.min=0 g.max=255\n    //% b.min=0 b.max=255\n    //% subcategory=\"Rainbow\"\n    export function rainbowRgbToColor(r: number, g: number, b: number): number {\n        return (r << 16) | (g << 8) | b;\n    }\n\n    /**\n     * Convert HSL values to a color number\n     * @param h Hue (0-360)\n     * @param s Saturation (0-100)\n     * @param l Luminosity (0-100)\n     */\n    //% blockId=\"rainbow_hsl_to_color\"\n    //% value.defl='#ff0000' \n    //% weight=50 blockGap=15\n    //% subcategory=\"Rainbow\"\n    //% block=\"hue %h|saturation %s|luminosity %l\"\n    //% h.min=0 h.max=360\n    //% s.min=0 s.max=100\n    //% l.min=0 l.max=100\n    export function rainbowHslToColor(h: number, s: number, l: number): number {\n        return rainbowHslToRgb(h, s, l); // Custom function for HSL to RGB\n    }\n\n    /**\n     * Convert HSL values to RGB\n     * @param h Hue (0-360)\n     * @param s Saturation (0-100)\n     * @param l Luminosity (0-100)\n     * @returns A packed RGB number (24-bit)\n     */\n    function rainbowHslToRgb(h: number, s: number, l: number): number {\n        h = h % 360; // Ensure hue wraps around 360\n        s = s / 100; // Convert saturation to a decimal\n        l = l / 100; // Convert luminosity to a decimal\n\n        const c = (1 - Math.abs(2 * l - 1)) * s; // Chroma\n        const x = c * (1 - Math.abs((h / 60) % 2 - 1)); // Second largest component\n        const m = l - c / 2;\n\n        let r = 0, g = 0, b = 0;\n\n        if (h >= 0 && h < 60) {\n            r = c; g = x; b = 0;\n        } else if (h >= 60 && h < 120) {\n            r = x; g = c; b = 0;\n        } else if (h >= 120 && h < 180) {\n            r = 0; g = c; b = x;\n        } else if (h >= 180 && h < 240) {\n            r = 0; g = x; b = c;\n        } else if (h >= 240 && h < 300) {\n            r = x; g = 0; b = c;\n        } else if (h >= 300 && h < 360) {\n            r = c; g = 0; b = x;\n        }\n\n        // Convert RGB components to 8-bit values and pack into a single integer\n        const red = Math.round((r + m) * 255);\n        const green = Math.round((g + m) * 255);\n        const blue = Math.round((b + m) * 255);\n\n        return (red << 16) | (green << 8) | blue;\n    }\n\n    /**\n     * Custom function to set a specific LED's color on the rainbow LED strip\n     * @param index LED index\n     * @param color RGB color\n     */\n    function rainbowSetLedColor(index: number, color: number): void {\n        // Send the appropriate signal to the LEDs\n        let r = (color >> 16) & 0xFF;\n        let g = (color >> 8) & 0xFF;\n        let b = color & 0xFF;\n\n        // Logic to send r, g, and b to the specific LED\n        rainbowSendSignalToLed(index, r, g, b);\n    }\n\n    /**\n     * Function to send RGB signal to a specific LED in the rainbow strip\n     */\n    function rainbowSendSignalToLed(index: number, r: number, g: number, b: number): void {\n        // Use custom bit-banging logic or timing logic here\n    }\n\n    /**\n     * Function to apply updates to the rainbow LEDs\n     */\n    function rainbowUpdateLeds(): void {\n        // Trigger any necessary latch or update commands for the LEDs\n    }\n\n    /**\n     * Breathing effect on the Rainbow strip.\n     * The LED brightness will gradually increase and decrease, creating a \"breathing\" effect.\n     * @param duration The total duration for the breathing cycle in seconds.\n     * @param color The color for the breathing effect.\n     */\n    //% subcategory=\"Rainbow\"\n    //% blockId=\"rainbow_breathing_effect\"\n    //% block=\"start breathing effect for %duration|seconds with color %color\"\n    //% group=Effects weight=85 blockGap=8\n    //% color.shadow=\"brightColorNumberPicker\"\n    //% duration.defl=5\n    export function rainbowBreathingEffect(duration: number, color: number): void {\n        let cycleTime = (duration * 1000) / 2; // Convert seconds to milliseconds and split into fade-in and fade-out\n        let steps = 255; // Number of steps for fading (brightness from 0 to 255)\n        let stepTime = cycleTime / steps; // Time per step in milliseconds\n\n        // Gradually increase brightness (fade-in)\n        for (let brightness = 0; brightness <= 255; brightness++) {\n            setRainbowBrightness(brightness); // Set brightness\n            applyRainbowColor(color);        // Apply the selected color\n            basic.pause(stepTime);\n        }\n\n        // Gradually decrease brightness (fade-out)\n        for (let brightness = 255; brightness >= 0; brightness--) {\n            setRainbowBrightness(brightness); // Set brightness\n            applyRainbowColor(color);        // Apply the selected color\n            basic.pause(stepTime);\n        }\n    }\n\n    /**\n     * Apply the selected color to the Rainbow LED strip\n     * @param color The color to set\n     */\n    function applyRainbowColor(color: number): void {\n        let red = (color >> 16) & 0xFF;\n        let green = (color >> 8) & 0xFF;\n        let blue = color & 0xFF;\n        for (let i = 0; i < rainbowNumLeds; i++) {\n            setRainbowLedColorRaw(i, red, green, blue);\n        }\n        showRainbowBuffer(); // Refresh the LEDs\n    }\n\n\n    /**\n     * Color Wipe effect on the Rainbow strip.\n     * LEDs light up one by one in a selected color.\n     * @param color the color to wipe\n     * @param delay time between each LED lighting in ms\n     */\n    //% subcategory=\"Rainbow\"\n    //% blockId=\"rainbow_color_wipe\"\n    //% block=\"color wipe with %color|delay %delay s\"\n    //% group=Effects weight=80 blockGap=8\n    //% color.shadow=\"brightColorNumberPicker\"\n    export function rainbowColorWipe(color: number, delay: number): void {\n        let red = (color >> 16) & 0xFF;\n        let green = (color >> 8) & 0xFF;\n        let blue = color & 0xFF;\n\n        for (let i = 0; i < rainbowNumLeds; i++) {\n            setRainbowLedColorRaw(i, red, green, blue);\n            showRainbowBuffer();\n            basic.pause(delay * 1000);\n        }\n    }\n\n    /**\n     * Rainbow cycle effect on the Rainbow strip.\n     * Displays a smooth rainbow transition across all LEDs.\n     * @param duration total duration of the rainbow cycle in seconds\n     */\n    //% subcategory=\"Rainbow\"\n    //% blockId=\"rainbow_rainbow_cycle\"\n    //% block=\"rainbow cycle for %duration s\"\n    //% group=Effects weight=75 blockGap=8\n    export function rainbowCycle(duration: number): void {\n        let steps = 255; // Number of color steps\n        let stepTime = (duration * 1000) / steps; // Time per step in ms\n\n        for (let j = 0; j < steps; j++) {\n            for (let i = 0; i < rainbowNumLeds; i++) {\n                let color = wheel((i * 256 / rainbowNumLeds + j) & 255);\n                let red = (color >> 16) & 0xFF;\n                let green = (color >> 8) & 0xFF;\n                let blue = color & 0xFF;\n                setRainbowLedColorRaw(i, red, green, blue);\n            }\n            showRainbowBuffer();\n            basic.pause(stepTime);\n        }\n    }\n\n    /**\n     * Helper function to generate a color from the wheel position\n     * @param position wheel position (0-255)\n     */\n    function wheel(position: number): number {\n        if (position < 85) {\n            return (position * 3 << 16) | ((255 - position * 3) << 8);\n        } else if (position < 170) {\n            position -= 85;\n            return ((255 - position * 3) << 16) | (position * 3);\n        } else {\n            position -= 170;\n            return (position * 3 << 8) | (255 - position * 3);\n        }\n    }\n\n    /**\n     * Twinkle effect on the Rainbow strip.\n     * Random LEDs light up briefly.\n     * @param color the color of the twinkle\n     * @param duration total duration of the twinkle effect in seconds\n     */\n    //% subcategory=\"Rainbow\"\n    //% blockId=\"rainbow_twinkle_effect\"\n    //% block=\"twinkle with %color|for %duration s\"\n    //% group=Effects weight=70 blockGap=8\n    //% color.shadow=\"brightColorNumberPicker\"\n    export function rainbowTwinkle(color: number, duration: number): void {\n        let endTime = input.runningTime() + duration * 1000;\n        while (input.runningTime() < endTime) {\n            let index = Math.randomRange(0, rainbowNumLeds - 1);\n            let red = (color >> 16) & 0xFF;\n            let green = (color >> 8) & 0xFF;\n            let blue = color & 0xFF;\n\n            setRainbowLedColorRaw(index, red, green, blue);\n            showRainbowBuffer();\n            basic.pause(100);\n\n            setRainbowLedColorRaw(index, 0, 0, 0); // Turn off the LED\n            showRainbowBuffer();\n            basic.pause(100);\n        }\n    }\n\n\n    /**\n     * Theater Chase effect on the Rainbow strip.\n     * A pattern of moving dots in a specific color.\n     * @param color the color of the chase\n     * @param duration total duration of the chase effect in seconds\n     */\n    //% subcategory=\"Rainbow\"\n    //% blockId=\"rainbow_theater_chase\"\n    //% block=\"theater chase with color %color|for %duration|s\"\n    //% group=Effects weight=65 blockGap=8\n    //% color.shadow=\"brightColorNumberPicker\"\n    export function rainbowTheaterChase(color: number, duration: number): void {\n        let red = (color >> 16) & 0xFF;\n        let green = (color >> 8) & 0xFF;\n        let blue = color & 0xFF;\n\n        let endTime = input.runningTime() + duration * 1000; // Duration in milliseconds\n\n        while (input.runningTime() < endTime) {\n            for (let q = 0; q < 3; q++) {\n                // Light up every 3rd LED starting at position q\n                for (let i = 0; i < rainbowNumLeds; i += 3) {\n                    let index = i + q;\n                    if (index < rainbowNumLeds) {\n                        setRainbowLedColorRaw(index, red, green, blue);\n                    }\n                }\n                showRainbowBuffer();\n                basic.pause(50);\n\n                // Turn off the same LEDs\n                for (let i = 0; i < rainbowNumLeds; i += 3) {\n                    let index = i + q;\n                    if (index < rainbowNumLeds) {\n                        setRainbowLedColorRaw(index, 0, 0, 0); // Turn off the LED\n                    }\n                }\n                showRainbowBuffer();\n                basic.pause(50);\n            }\n        }\n\n        // Clear all LEDs after the duration ends\n        clearRainbow();\n    }\n\n    /**\n     * Wave effect on the Rainbow strip.\n     * Brightness varies across the strip in a sine wave pattern.\n     * @param color the base color of the wave\n     * @param duration total duration of the wave effect in seconds\n     */\n    //% subcategory=\"Rainbow\"\n    //% blockId=\"rainbow_wave_effect\"\n    //% block=\"wave effect with %color|for %duration s\"\n    //% group=Effects weight=60 blockGap=8\n    //% color.shadow=\"brightColorNumberPicker\"\n    export function rainbowWave(color: number, duration: number): void {\n        let red = (color >> 16) & 0xFF;\n        let green = (color >> 8) & 0xFF;\n        let blue = color & 0xFF;\n\n        let steps = 255;\n        let stepTime = (duration * 1000) / steps;\n\n        for (let j = 0; j < steps; j++) {\n            for (let i = 0; i < rainbowNumLeds; i++) {\n                let brightness = (Math.sin((i + j) * Math.PI / 180) + 1) * 127.5; // Sine wave\n                setRainbowLedColorRaw(i, (red * brightness) / 255, (green * brightness) / 255, (blue * brightness) / 255);\n            }\n            showRainbowBuffer();\n            basic.pause(stepTime);\n        }\n    }\n}\n"}]}],"snapshots":[{"timestamp":1733900476969,"editorVersion":"7.0.51","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"onebit\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1733900510984}